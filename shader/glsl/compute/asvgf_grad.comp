

#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#include "../constants.h"
#include "asvgf.glsl"
#include "../raytracer/gbuffer.glsl"
#include "../raytracer/rt_Helper.glsl"
#include "../raytracer/defines.glsl"
#include "../raytracer/vertexData.glsl"

layout(binding = BINDING_OFFSET_GLOBAL_UBO, set = 0) uniform global_ubo
{
	GlobalUbo ubo;
};
layout(binding = BINDING_OFFSET_GLOBAL_UBO_PREV, set = 0) uniform global_ubo_prev
{
	GlobalUbo uboPrev;
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// #define GLOBAL_UBO_DESC_SET_IDX 0
// #include "global_ubo.h"

// #define GLOBAL_TEXTURES_DESC_SET_IDX 1
// #include "global_textures.h"

// #include "utils.glsl"
// #include "asvgf.glsl"

// // Gradient for HF and SPEC channels is computed as the relative difference between
// // path tracer outputs on the current and previous frame, for a given gradient pixel. 
float get_gradient(float l_curr, float l_prev)
{
	float l_max = max(l_curr, l_prev);

	if(l_max == 0)
		return 0;

	float ret = abs(l_curr - l_prev) / l_max;
	ret *= ret; // make small changes less significant
	
	return ret;
}

void
main()
{

	ivec2 ipos = ivec2(gl_GlobalInvocationID);
	if(any(greaterThanEqual(ipos, ivec2(ubo.width, ubo.height) / GRAD_DWN)))
		return;

	uint u = imageLoad(gradSmplPosASVGFBuffer, ipos).r;

	vec2 grad_lf = vec2(0);
	float grad_hf = 0;
	float grad_spec = 0;

	// Process reprojected HF and SPEC samples
	if(u != 0u)
	{
		/* position of sample inside of stratum in the current frame */
		ivec2 grad_strata_pos = ivec2(
				u >> (STRATUM_OFFSET_SHIFT * 0),
				u >> (STRATUM_OFFSET_SHIFT * 1)) & STRATUM_OFFSET_MASK;

		/* full position in current frame for gradient sample */
		ivec2 grad_sample_pos_curr = ipos * GRAD_DWN + grad_strata_pos;

		vec2 prev_hf_spec_lum = imageLoad(gradHfASVGFPing, ipos).rg;

		vec3 curr_hf = imageLoad(directIlluminationGBuffer, grad_sample_pos_curr).xyz;	
		//vec3 curr_spec = unpackRGBE(texelFetch(TEX_PT_COLOR_SPEC, grad_sample_pos_curr, 0).x);

		grad_hf = get_gradient(luminance(curr_hf), prev_hf_spec_lum.x);
		//grad_spec = get_gradient(luminance(curr_spec), prev_hf_spec_lum.y);

		// Reflections and refractions are not reprojected correctly, so camera motion
		// generates false gradients - mitigate that with a scaling factor.
		// int checkerboard_flags = int(texelFetch(TEX_PT_VIEW_DIRECTION, grad_sample_pos_curr, 0).w);
		// if((checkerboard_flags & (CHECKERBOARD_FLAG_REFLECTION | CHECKERBOARD_FLAG_REFRACTION)) != 0)
		// {
		// 	grad_hf *= global_ubo.flt_grad_transparent;
		// 	grad_spec *= global_ubo.flt_grad_transparent;
		// }
	}

	//imageStore(IMG_ASVGF_GRAD_LF_PING, ipos, vec4(grad_lf, 0, 0));
	imageStore(gradHfASVGFPing, ipos, vec4(grad_hf, grad_spec, 0, 0));
}