#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "../constants.h"
#include "../raytracer/defines.glsl"
#include "asvgf.glsl"
#include "../raytracer/rt_Helper.glsl"

layout(binding = BINDING_OFFSET_GLOBAL_UBO, set = 0) uniform global_ubo
{
	GlobalUbo ubo;
};

layout(push_constant) uniform push {
    layout(offset = 0) int iteration;
};

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;


void main() {
    ivec2 ipos = ivec2(gl_GlobalInvocationID);
    vec4 color = imageLoad(IMG_ASVGF_COLOR, ipos);

    

    // if(ubo.tonemappingReinhard < 1) {
    //     float maxL = 0;
    //     ivec2 size = ivec2(ubo.width, ubo.height);
    //     for(int x = 0; x< size.x; x++){
    //         for(int y = 0; y< size.y; y++){
    //         maxL = max(maxL, luminance(imageLoad(IMG_ASVGF_COLOR, ivec2(x, y)).xyz));
    //     }
    //     }

    //     color.xyz = reinhard_extended_luminance(color.xyz, maxL);
    // }
	//vec2(textureSize(tex, 0))

    if(ubo.taa == 1) imageStore(IMG_ASVGF_COLOR, ipos, vec4(color.xyz, 1));
	else imageStore(imgtaaASVGF, ipos, vec4(color.xyz, 1));
}