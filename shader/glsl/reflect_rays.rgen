#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable
#pragma optionNV (unroll all)
#include "constants.h"
#include "rt_defines.glsl"
#include "rt_helper.glsl"
#include "rt_sky.glsl"
#include "rt_texture.glsl"
#include "rt_vattributes.glsl"
#include "gbuffer.glsl"

// Bindings
layout(binding = BINDING_OFFSET_GLOBAL_UBO, set = 0) uniform global_ubo
{
	GlobalUbo ubo;
};
layout(binding = BINDING_OFFSET_GLOBAL_UBO_PREV, set = 0) uniform global_ubo_prev
{
	GlobalUbo uboPrev;
};
#include "traceRay.glsl"




void reflectionRefrection(){
	vec4 primary_albedo;
	vec3 normal;
	vec3 pos;
	uint cluster;
	uint material;
	float depth;
	vec3 motion;

	vec4 temp;
	uvec4 utemp;
	primary_albedo = imageLoad(albedoGBuffer, ivec2(gl_LaunchIDNV.xy));
	normal = imageLoad(normalGBuffer, ivec2(gl_LaunchIDNV.xy)).xyz;
	pos = imageLoad(posGBuffer, ivec2(gl_LaunchIDNV.xy)).xyz;
	utemp = imageLoad(objectGBuffer, ivec2(gl_LaunchIDNV.xy));
	material = utemp.x;
	cluster = utemp.y;

	vec3 P = pos;
	vec3 N = normal;
	vec3 shadeColor = primary_albedo.xyz;

	vec4 color = vec4(0);
	if (isGlass(material)){
		vec3 direction = normalize(P - ubo.camPos.xyz);
		float n1, n2, ndotr = dot(direction, N);  
		if( ndotr > 0.0f ) {
			n1 = 1.0; 
			n2 = 1.5;
			N = -N;
		} else {
			n1 = 1.5;
			n2 = 1.0; 
		}


		float F = pow(1.0 - max(0.0, -dot(direction, N)), 5.0);
		F = mix(0.5, 1.0, F);

		//direction = normalize(direction);
		vec3 dirReflection = reflect(direction, N);
		vec3 dirRefraction = refract( direction, N, n2/n1 );
		dirRefraction = refract( dirRefraction, N, n1/n2 );


		Ray ray;
		ray.origin = P;
		ray.direction = dirReflection;
		ray.t_min = 0.01;
		ray.t_max = 10000.0;
		trace_ray(ray, RAY_MIRROR_OPAQUE_VISIBLE | RAY_MIRROR_PARTICLE_VISIBLE);

		vec4 albedoReflection;
		if(!found_intersection(rp)){
			albedoReflection = sampleSky(ray.direction);
		} else {
			HitPoint hp = getHitPoint(rp);
			Triangle triangle = getTriangle(rp);
			albedoReflection = getTextureLod2(hp,0);

		}

		ray.direction = dirRefraction;
		trace_ray(ray, RAY_MIRROR_OPAQUE_VISIBLE | RAY_MIRROR_PARTICLE_VISIBLE);
		vec4 albedoRefraction;
		if(!found_intersection(rp)){
			// strange color
			albedoRefraction = sampleSky(ray.direction);
		} else {
			HitPoint hp = getHitPoint(rp);
			Triangle triangle = getTriangle(rp);
			albedoRefraction = getTextureLod2(hp,0);
		}

		float r0 = (n1-n2)/(n1+n2); r0 *= r0;
		float fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),5.);
		float ratio = 0.2;
		vec4 albedo = ratio * albedoReflection + (1 - ratio) * albedoRefraction;

		if(primary_albedo.w == 0.0) color = albedo;
		else color = alpha_blend(primary_albedo, albedo);
		//shadeColor += albedo.xyz;
	} else if(isMirror(material)){
		vec4 mirrorColor = primary_albedo;
		mirrorColor = 1 - vec4(mirrorColor/1);
		// 1 - vec4(src/1)
		Ray ray;
		ray.origin = P;
		ray.direction = reflect(P - ubo.camPos.xyz, N);
		ray.t_min = 0.01;
		ray.t_max = 10000.0;
		trace_ray(ray, RAY_MIRROR_OPAQUE_VISIBLE | RAY_MIRROR_PARTICLE_VISIBLE);
		
		if(!found_intersection(rp)){
		 	color = vec4(alpha_blend_premultiplied(rp.transparent, sampleSky(ray.direction)).xyz,1);
		}else{

		HitPoint hp = getHitPoint(rp);
		Triangle triangle = getTriangle(rp);

			vec4 mirror_albedo = getTextureLod2( hp,0);
			color = vec4(mirrorColor.xyz * mirror_albedo.xyz,1);
		}
	} 
	imageStore(reflectionGBuffer, ivec2(gl_LaunchIDNV.xy), vec4(color));
}

void main() 
{
	reflectionRefrection();
}

