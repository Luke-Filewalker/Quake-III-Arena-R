#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : require
#include "rt_defines.glsl"
#include "rt_vattributes.glsl"
#include "rt_texture.glsl"
#include "rt_helper.glsl"
#include "constants.h"

hitAttributeNV vec2 attribs;
layout(location = 0) rayPayloadInNV RayPayload rp;

void main()
{
  HitPoint hp = getHitPoint(gl_InstanceID, gl_PrimitiveID, attribs);


  vec4 contrib = vec4(0,0,0,0);
  // Explotion bullets etc
  if((iData.data[gl_InstanceID].material & MATERIAL_KIND_BULLET) == MATERIAL_KIND_BULLET){
    contrib = texture(texure_array[uint(uint(iData.data[gl_InstanceID].texIdx))], hp.uv);
    //contrib *= (hp.color/255);
    contrib = vec4(contrib.xyz,0);
    if(rp.max_transparent_distance < gl_HitTNV)
      rp.transparent = alpha_blend_premultiplied(rp.transparent, contrib);
    else
      rp.transparent = alpha_blend_premultiplied(contrib, rp.transparent);
  }
  else if((iData.data[gl_InstanceID].material & MATERIAL_FLAG_SEE_THROUGH) == MATERIAL_FLAG_SEE_THROUGH) {
    rp.transparent = vec4(1,0,0,0);
  }
  // blood smoke etc
  else {
    contrib = texture(texure_array[uint(uint(iData.data[gl_InstanceID].texIdx))], hp.uv);
    if((iData.data[gl_InstanceID].material & MATERIAL_FLAG_NEEDSCOLOR) > 0) {
      contrib *= (hp.color/255);
      contrib *= contrib.w;
    }
    if(rp.max_transparent_distance < gl_HitTNV)
      rp.transparent = alpha_blend_premultiplied(rp.transparent, contrib);
    else
      rp.transparent = alpha_blend_premultiplied(contrib, rp.transparent);
  }

  rp.max_transparent_distance = gl_HitTNV;
	ignoreIntersectionNV();
}