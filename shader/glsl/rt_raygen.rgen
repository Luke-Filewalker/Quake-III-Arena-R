#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable
#pragma optionNV (unroll all)
#include "constants.h"
#include "rt_defines.glsl"
#include "rt_helper.glsl"
#include "rt_sky.glsl"
#include "rt_vattributes.glsl"
#include "rt_texture.glsl"

// Push Constants
layout(push_constant) uniform PushConstant {
    //layout(offset = 0) mat4 inverseView;
    //layout(offset = 64) mat4 inverseProj;
    layout(offset = 0) vec4 position;
	layout(offset = 16) vec4 positionPortal;
};

// Bindings
layout(binding = BINDING_OFFSET_AS, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;


layout(binding = BINDING_OFFSET_GLOBAL_UBO, set = 0) uniform global_ubo
{
	RTUbo ubo;
};

layout(binding = BINDING_OFFSET_UBO_LIGHTS, set = 0) uniform LightList 
{
	LightList_s lightList;
} uboLights;

// Specific
layout(location = PAYLOAD_BRDF) rayPayloadNV RayPayload rp;
layout(location = PAYLOAD_SHADOW) rayPayloadNV ShadowRayPayload rp_shadow;


Ray
get_primary_ray(vec2 pos_cs)
{
	vec4 v_near = ubo.inverseViewMat * ubo.inverseProjMat * vec4(pos_cs, -1.0, 1.0);
	vec4 v_far  = ubo.inverseViewMat * ubo.inverseProjMat * vec4(pos_cs,  0.0, 1.0);
	v_near /= v_near.w;
	v_far  /= v_far.w;

	Ray ray;
	ray.origin = v_near.xyz;
	ray.direction = normalize(v_far.xyz - v_near.xyz);
	ray.t_min = 0.01;
	ray.t_max = 10000.0;
	return ray;
}

void trace_ray(Ray ray, uint cullMask)
{
	const uint rayFlags = gl_RayFlagsCullFrontFacingTrianglesNV;//gl_RayFlagsOpaqueNV;// | gl_RayFlagsCullBackFacingTrianglesNV;
	//const uint rayFlags = gl_RayFlagsOpaqueNV | gl_RayFlagsCullBackFacingTrianglesNV;
	//const uint cullMask = RAY_FIRST_PERSON_VISIBLE;
	rp.transparent = vec4(0);
	rp.max_transparent_distance = 0;

	traceNV( topLevelAS, rayFlags, cullMask,
			SBT_RCHIT_OPAQUE /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, SBT_RMISS_PATH_TRACER /*missIndex*/,
			ray.origin, ray.t_min, ray.direction, ray.t_max, PAYLOAD_BRDF);
}


float trace_shadow_ray(vec3 pos, vec3 dir, float t_min, float t_max)
{
	const uint rayFlags = gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsSkipClosestHitShaderNV;
	uint cullMask = RAY_MIRROR_OPAQUE_VISIBLE;
	if(is_player(rp)) {
		cullMask = RAY_FIRST_PERSON_OPAQUE_VISIBLE;
	}
	
	Ray ray;
	ray.origin = pos;
	ray.direction = dir;
	ray.t_min = t_min;
	ray.t_max = t_max - t_min;

	rp_shadow.visFactor = 0.0f;

	traceNV( topLevelAS, rayFlags, cullMask,
			SBT_RCHIT_SHADOW_RAY /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, SBT_RMISS_SHADOW_RAY /*missIndex*/,
			ray.origin, ray.t_min, ray.direction, ray.t_max, PAYLOAD_SHADOW);

	return rp_shadow.visFactor;
}

// void trace_shadow_ray(Ray ray, uint cullMask)
// {
// 	const uint rayFlags = 0;//gl_RayFlagsOpaqueNV;// | gl_RayFlagsCullBackFacingTrianglesNV;
// 	//const uint rayFlags = gl_RayFlagsOpaqueNV | gl_RayFlagsCullBackFacingTrianglesNV;
// 	//const uint cullMask = RAY_FIRST_PERSON_VISIBLE;
// 	rp_shadow.missed = 0;

// 	traceNV( topLevelAS, rayFlags, cullMask,
// 			SBT_RCHIT_OPAQUE /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, SBT_RMISS_PATH_TRACER /*missIndex*/,
// 			ray.origin, ray.t_min, ray.direction, ray.t_max, PAYLOAD_SHADOW;
// }

vec4 getTextureLod(vec2 screen_coord_cs, Triangle triangle, HitPoint hp){
	vec2 tex_coord = hp.uv0;
	Ray ray_x = get_primary_ray(screen_coord_cs + vec2(2.0 / float(gl_LaunchSizeNV.x), 0));
	Ray ray_y = get_primary_ray(screen_coord_cs - vec2(0, 2.0 / float(gl_LaunchSizeNV.y)));

	vec3 bary_x = compute_barycentric(triangle.pos, ray_x.origin, ray_x.direction);
	vec3 bary_y = compute_barycentric(triangle.pos, ray_y.origin, ray_y.direction);

	vec3 pos_ws_x= triangle.pos * bary_x;
	vec3 pos_ws_y= triangle.pos * bary_y;

	vec2 tex_coord_x = triangle.uv0 * bary_x;
	vec2 tex_coord_y = triangle.uv0 * bary_y;
	tex_coord_x -= tex_coord;
	tex_coord_y -= tex_coord;
	tex_coord_x *= 0.5;
	tex_coord_y *= 0.5;

	TextureData d = unpackTextureData(hp.tex0);
	vec4 color;
	vec4 tex = global_textureGrad(d.tex0, hp.uv0, tex_coord_x, tex_coord_y);
	color = vec4(tex.xyz, 1);
	if(d.tex0Color) color *= (hp.color0/255);

	if(d.tex1 != -1){
		tex_coord = hp.uv1;
		tex_coord_x = triangle.uv1 * bary_x;
		tex_coord_y = triangle.uv1 * bary_y;
		tex_coord_x -= tex_coord;
		tex_coord_y -= tex_coord;
		tex_coord_x *= 0.5;
		tex_coord_y *= 0.5;
		tex = global_textureGrad(d.tex1, hp.uv1, tex_coord_x, tex_coord_y);
		if(d.tex1Color) tex *= (hp.color1/255);

		if(d.tex1Blend) {
			color = alpha_blend(tex, color);
		}
		else color += tex;
	} else return color;

	d = unpackTextureData(hp.tex1);
	if(d.tex0 != -1){
		tex_coord = hp.uv2;
		tex_coord_x = triangle.uv2 * bary_x;
		tex_coord_y = triangle.uv2 * bary_y;
		tex_coord_x -= tex_coord;
		tex_coord_y -= tex_coord;
		tex_coord_x *= 0.5;
		tex_coord_y *= 0.5;
		tex = global_textureGrad(d.tex0, hp.uv2, tex_coord_x, tex_coord_y);
		if(d.tex0Color) tex *= (hp.color2/255);

		if(d.tex0Blend) {
			color = alpha_blend(tex, color);
		}
		else color += tex;
	} else return color;

	if(d.tex1 != -1){
		tex_coord = hp.uv3;
		tex_coord_x = triangle.uv3 * bary_x;
		tex_coord_y = triangle.uv3 * bary_y;
		tex_coord_x -= tex_coord;
		tex_coord_y -= tex_coord;
		tex_coord_x *= 0.5;
		tex_coord_y *= 0.5;
		tex = global_textureGrad(d.tex1, hp.uv3, tex_coord_x, tex_coord_y);
		if(d.tex1Color) tex *= (hp.color3/255);

		if(d.tex1Blend) {
			color = alpha_blend(tex, color);
		}
		else color += tex;
	} 
	return color;
}

vec3
getRandomLight(int i){
	int lightIDX = int( round( get_rng(RNG_C(i), int(ubo.frameIndex)) * uboLights.lightList.numLights ) );
	//if(uboLights.lightList.lights[lightIDX].cluster > 500) return uboLights.lightList.lights[0].pos.xyz;
	// tr.world->vis + cluster * tr.world->clusterBytes;
	return uboLights.lightList.lights[lightIDX].pos.xyz;
}
vec3
getLight(int i){
	return uboLights.lightList.lights[i].pos.xyz;
}

bool
lightVisible(int i, uint hitCluster){
	uint cluster = uboLights.lightList.lights[i].cluster;
	if((imageLoad(vis_data, ivec2(cluster>>3, hitCluster)).r  & (1<<(cluster&7))) > 0 ) return true;
	return false;
}

#define KD 0.05 // diffuse

#define ALBEDO_MULT 1.3
vec4 path_tracer(){
	const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
	const vec2 inUV0 = pixelCenter/vec2(gl_LaunchSizeNV.xy);
	const vec2 screen_coord_cs  = inUV0 * 2.0 - 1.0;

	// init ray
	Ray ray = get_primary_ray(screen_coord_cs);
	//ray.origin = position.xyz;
	//vec4 target = ubo.inverseProj * vec4(screen_coord_cs, -1, 1) ;
	//ray.direction = (ubo.inverseView*vec4(normalize(target.xyz), 0)).xyz;
	//ray.t_min = 0.01;
	//ray.t_max = 10000.0;

	// calc ray length
	trace_ray(ray, RAY_FIRST_PERSON_OPAQUE_VISIBLE);
	ray.t_max = rp.hit_distance + 0.001;

	trace_ray(ray, RAY_FIRST_PERSON_OPAQUE_VISIBLE | RAY_FIRST_PERSON_PARTICLE_VISIBLE);
	if(!found_intersection(rp)){
		//return alpha_blend_premultiplied(rp.transparent, sampleSky(ray.direction));
		return sampleSky(ray.direction);
	}

	HitPoint hp = getHitPoint(rp);
	Triangle triangle = getTriangle(rp);

	 vec4 color = vec4(0,0,0,0);
	if(is_mirror(rp)){
		color = global_texture((hp.tex0 & TEX1_IDX_MASK) >> TEX_SHIFT_BITS, hp.uv0);
		color = 1 - vec4(color/1);
		// 1 - vec4(src/1)
		ray.origin = ray.origin + ray.direction * rp.hit_distance;
		ray.direction = reflect(ray.direction, hp.normal);
		ray.t_max = 10000.0;
		trace_ray(ray, RAY_MIRROR_OPAQUE_VISIBLE | RAY_MIRROR_PARTICLE_VISIBLE);
		if(!found_intersection(rp)){
			return alpha_blend_premultiplied(rp.transparent, sampleSky(ray.direction));
		}
		HitPoint hp2 = getHitPoint(rp);
		Triangle triangle2 = getTriangle(rp);
		//color += global_texture(hp2.tex0 & TEX0_IDX_MASK, hp2.uv0);
		return global_texture(hp2.tex0 & TEX0_IDX_MASK, hp2.uv0) * color;
	} 

	vec4 contrib = vec4(0,0,0,0);

	vec3 fromCam = ray.direction.xyz;
	vec3 primary_albedo = getTextureLod(screen_coord_cs, triangle, hp).xyz;
	if(is_glass(rp)){
		primary_albedo += vec3(0,0,1);
	}
	if(is_light(rp)){
	 	primary_albedo += vec3(1,0,0);
		return vec4(primary_albedo,1);
	}

	bool isPlayer = is_player(rp);

	vec3 P = hp.pos.xyz;
	vec3 N = hp.normal;

	uint hitCluster = hp.cluster;

	vec3 shadeColor = vec3(0);
	for(int i = 0; i < uboLights.lightList.numLights; i++){
		//if(hitCluster == 1333) break;
		if(!lightVisible(i, /*ubo.currentCluster*/ hitCluster)) continue;
		vec3 posLight = getLight(i);
		vec3 toLight = posLight - P;
		vec3 L = normalize(toLight);
		float distToLight =	length(toLight);
		vec3 lightIntensity = vec3(0.55);
		if(i > 30 && i < 50) lightIntensity = vec3(0.55,0,0);

	 	float shadowMult =  /*float(uboLights.lightList.numLights) */  trace_shadow_ray(P, L, 0.01f, distToLight);

		vec3 pPos = vec3(ubo.viewMat[3].xyz);

		//if(dot(N, L) < 0) N = -N;
		float LdotN = clamp(dot(N, L), 0.0, 1.0);

		// Accumulate our Lambertian shading color
		shadeColor += shadowMult * LdotN * lightIntensity; 
	}

	

	// Modulate based on the physically based Lambertian term (albedo/pi)
	shadeColor *= primary_albedo.rgb / M_PI;
	
	// uint seed = initRand(gl_LaunchIDNV.x, gl_LaunchIDNV.y, 16/* = 16*/);
	// // indirect
	// if (true)
	// {
	// 	for (uint b = 0; b < 5; ++b)
	// 	{
	// 		// Select a random direction for our diffuse interreflection ray.
	// 		vec3 bounceDir;
			
	// 		bool gCosSampling = true;
	// 		if (gCosSampling)
	// 			bounceDir = getCosHemisphereSample(seed, N);      // Use cosine sampling
	// 		else
	// 			bounceDir = getUniformHemisphereSample(seed, N);  // Use uniform random samples

	// 		// Get NdotL for our selected ray direction
	// 		float NdotL = clamp(dot(N, bounceDir), 0.0, 1.0);

	// 		// Shoot our indirect global illumination ray
	// 		Ray indirectRay = {
	// 			P, bounceDir, 0.01, 10000
	// 		};

	// 		trace_ray(indirectRay, RAY_MIRROR_OPAQUE_VISIBLE | RAY_MIRROR_PARTICLE_VISIBLE);
	// 		vec3 bounceColor;
	// 		bool miss = false;
	// 		if(!found_intersection(rp)){
	// 			bounceColor = sampleSky(ray.direction).xyz;
	// 			miss = true;
	// 		} else {
	// 			HitPoint hpIndirect = getHitPoint(rp);
	// 			Triangle tIndirect = getTriangle(rp);
	// 			//vec3 bounceColor = (global_texture(hpIndirect.tex0 & TEX0_IDX_MASK, hpIndirect.uv0) * color).xyz;
	// 			bounceColor = getTextureLod(screen_coord_cs, tIndirect, hpIndirect).xyz;

	// 			P = hpIndirect.pos.xyz;
	// 			N = hpIndirect.normal;

	// 			for(int i = 0; i < 1/*uboLights.lightList.numLights*/; i++){
	// 				vec3 posLight = getRandomLight(i);
	// 				vec3 toLight = posLight - P;
	// 				vec3 L = normalize(toLight);
	// 				float distToLight =	length(toLight);
	// 				vec3 lightIntensity = vec3(0.25);

	// 				float shadowMult =  trace_shadow_ray(P, L, 0.01f, distToLight);

	// 				float LdotN = clamp(dot(N, L), 0.0, 1.0);

	// 				// Accumulate our Lambertian shading color
	// 				shadeColor += shadowMult * LdotN * lightIntensity; 
	// 			}
	// 		}

	// 		//bounceColor = (NdotL > 0.50f) ? float3(0, 0, 0) : bounceColor;

	// 		// Probability of selecting this ray ( cos/pi for cosine sampling, 1/2pi for uniform sampling )
	// 		float sampleProb = gCosSampling ? (NdotL / M_PI) : (1.0f / (2.0f * M_PI));

	// 		// Accumulate the color.  For performance, terms could (and should) be cancelled here.
	// 		//shadeColor += (NdotL * bounceColor * difMatlColor.rgb / M_PI) / sampleProb;

	// 		shadeColor += (NdotL * bounceColor * primary_albedo.rgb / M_PI) / sampleProb;
	// 		if(miss) break;
	// 	}
	// }

	color = vec4(shadeColor, 1);

	//color = vec4(primary_albedo.rgb, 1);
	//color = alpha_blend( rp.transparent, vec4(primary_albedo.rgb,1) );

 //color = trace_shadow_ray2(P, L, 0.01f, distToLight) * vec4(primary_albedo, 1);

	return vec4(color.xyz, false);
}

void main() 
{
	vec4 color = path_tracer();
	color.rgb = max(vec3(0), color.rgb);
	if(any(isnan(color.rgb)))
		color.rgb = vec3(0);

	color.rgb = clamp_color(color.rgb, 128.0);

	imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(color.xyz,1));
}

