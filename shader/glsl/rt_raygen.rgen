#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#include "rt_defines.glsl"

layout(push_constant) uniform PushConstant {
    layout(offset = 0) mat4 inverseView;
    layout(offset = 64) mat4 inverseProj;
    layout(offset = 128) vec4 position;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;

layout(location = 0) rayPayloadNV RayPayload rp;

void main() 
{
	const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = vec4(position.xyz,1);
	vec4 target = inverseProj * vec4(d.x, d.y, -1, 1) ;
	vec4 direction = inverseView*vec4(normalize(target.xyz), 0);

	uint rayFlags = gl_RayFlagsCullBackFacingTrianglesNV;// = /*gl_RayFlagsOpaqueNV | */gl_RayFlagsCullFrontFacingTrianglesNV ;
	uint cullMask = FIRST_PERSON_VISIBLE;
	float tmin = 0.01;
	float tmax = 10000.0;

	// init payload
	rp.color = vec4(0,0,0,0);
	rp.depth = 0;
	rp.distance = 0;
	rp.cullMask = cullMask;

	vec4 pixelColor = vec4(0,0,0,0);
	traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
	pixelColor += rp.color;

	imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(pixelColor.xyz, 1));
}

/*
// Trace hit.
		origin.xyz = origin.xyz + rp.distance * direction.xyz;
	//pixelColor = vec4(pixelColor.w,pixelColor.w,pixelColor.w,pixelColor.w);
	if(pixelColor.w == 0) {
		traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
		pixelColor += rp.color;
	}else(rp.transparent > 0 && pixelColor.w != 1)  {
		traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
		pixelColor += rp.color;
			//pixelColor = vec4(((1-pixelColor.w) * pixelColor.xyz) + ((pixelColor.w) * rp.color.xyz), 1);
	}*/
/*
	for (uint s = 0; s < 5; ++s)
	{
		if (rp.distance < 0 || rp.transparent == 0)
		{				
			break;
		}
		// Trace hit.
		origin.xyz = origin.xyz + rp.distance * direction.xyz;

		if(pixelColor.w == 0) {
			traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
			pixelColor += rp.color;
		}
		else(pixelColor.w != 1)  {
			//traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
			//pixelColor = vec4(((1-pixelColor.w) * pixelColor.xyz) + ((pixelColor.w) * rp.color.xyz), 1);
		}
		*/
		//if((rp.transparent == 1) || (rp.transparent == 2 && pixelColor.w != 1))traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
		//pixelColor = blendColor(pixelColor, rp.color, uint(rp.blendFunc));
		//if(rp.transparent == 2) {

		//else pixelColor += rp.color;
		

		
	//}
	//traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz + (direction.xyz * rp.distance), tmin, direction.xyz, tmax, 0);
	
//}