#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable
#include "rt_defines.glsl"
#include "rt_helper.glsl"
#include "rt_sky.glsl"
#include "rt_vattributes.glsl"
#include "rt_texture.glsl"
#include "constants.h"

// Push Constants
layout(push_constant) uniform PushConstant {
    //layout(offset = 0) mat4 inverseView;
    //layout(offset = 64) mat4 inverseProj;
    layout(offset = 0) vec4 position;
	layout(offset = 16) vec4 positionPortal;
};

// Bindings
layout(binding = BINDING_OFFSET_AS, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;


layout(binding = 6, set = 0) uniform global_ubo
{
	RTUbo ubo;
};

layout(binding = 7, set = 0) uniform LightList 
{
	vec4 pos[RTX_MAX_LIGHTS];
	uint lightCount;
} uboLights;

// Specific
layout(location = PAYLOAD_BRDF) rayPayloadNV RayPayload rp;
layout(location = PAYLOAD_SHADOW) rayPayloadNV RayPayloadShadow rp_shadow;


Ray
get_primary_ray(vec2 pos_cs)
{
	vec4 v_near = ubo.inverseViewMat * ubo.inverseProjMat * vec4(pos_cs, -1.0, 1.0);
	vec4 v_far  = ubo.inverseViewMat * ubo.inverseProjMat * vec4(pos_cs,  0.0, 1.0);
	v_near /= v_near.w;
	v_far  /= v_far.w;

	Ray ray;
	ray.origin = v_near.xyz;
	ray.direction = normalize(v_far.xyz - v_near.xyz);
	ray.t_min = 0.01;
	ray.t_max = 10000.0;
	return ray;
}

void trace_ray(Ray ray, uint cullMask)
{
	const uint rayFlags = 0;//gl_RayFlagsOpaqueNV;// | gl_RayFlagsCullBackFacingTrianglesNV;
	//const uint rayFlags = gl_RayFlagsOpaqueNV | gl_RayFlagsCullBackFacingTrianglesNV;
	//const uint cullMask = RAY_FIRST_PERSON_VISIBLE;
	rp.transparent = vec4(0);
	rp.max_transparent_distance = 0;

	traceNV( topLevelAS, rayFlags, cullMask,
			SBT_RCHIT_OPAQUE /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, SBT_RMISS_PATH_TRACER /*missIndex*/,
			ray.origin, ray.t_min, ray.direction, ray.t_max, PAYLOAD_BRDF);
}
bool trace_shadow_ray(vec3 pos, vec3 dir, float t_min)
{
	const uint rayFlags = 0;
	uint cullMask = RAY_FIRST_PERSON_OPAQUE_VISIBLE | RAY_FIRST_PERSON_PARTICLE_VISIBLE;
	Ray ray;
	ray.origin = pos;
	ray.direction = dir;
	ray.t_min = t_min;//-0.01;
	ray.t_max = 10000.0;

	traceNV( topLevelAS, rayFlags, cullMask,
			SBT_RCHIT_OPAQUE /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, SBT_RMISS_PATH_TRACER /*missIndex*/,
			ray.origin, ray.t_min, ray.direction, ray.t_max, PAYLOAD_BRDF);

	if(found_intersection(rp)){
		if(is_light(rp)){
			return true;
		}
	}
	
	return false;
}

// void trace_shadow_ray(Ray ray, uint cullMask)
// {
// 	const uint rayFlags = 0;//gl_RayFlagsOpaqueNV;// | gl_RayFlagsCullBackFacingTrianglesNV;
// 	//const uint rayFlags = gl_RayFlagsOpaqueNV | gl_RayFlagsCullBackFacingTrianglesNV;
// 	//const uint cullMask = RAY_FIRST_PERSON_VISIBLE;
// 	rp_shadow.missed = 0;

// 	traceNV( topLevelAS, rayFlags, cullMask,
// 			SBT_RCHIT_OPAQUE /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, SBT_RMISS_PATH_TRACER /*missIndex*/,
// 			ray.origin, ray.t_min, ray.direction, ray.t_max, PAYLOAD_SHADOW;
// }

vec4 getTextureLod(vec2 screen_coord_cs, Triangle triangle, HitPoint hp){
	vec2 tex_coord = hp.uv;
	Ray ray_x = get_primary_ray(screen_coord_cs + vec2(2.0 / float(gl_LaunchSizeNV.x), 0));
	Ray ray_y = get_primary_ray(screen_coord_cs - vec2(0, 2.0 / float(gl_LaunchSizeNV.y)));

	vec3 bary_x = compute_barycentric(triangle.pos, ray_x.origin, ray_x.direction);
	vec3 bary_y = compute_barycentric(triangle.pos, ray_y.origin, ray_y.direction);

	vec3 pos_ws_x= triangle.pos * bary_x;
	vec3 pos_ws_y= triangle.pos * bary_y;

	vec2 tex_coord_x = triangle.uv * bary_x;
	vec2 tex_coord_y = triangle.uv * bary_y;
	tex_coord_x -= tex_coord;
	tex_coord_y -= tex_coord;

	tex_coord_x *= 0.5;
	tex_coord_y *= 0.5;
	vec4 color = global_textureGrad(iData.data[rp.instanceID].texIdx, hp.uv, tex_coord_x, tex_coord_y);
	if((iData.data[rp.instanceID].material & MATERIAL_FLAG_NEEDSCOLOR) > 0) {
		color *= (hp.color/255);
  	}
	  return color;
}

vec3
getLightDir(vec3 pos, int i){
	int lightIDX = int( round( get_rng(i, int(ubo.frameIndex)) * uboLights.lightCount ) );//float(uboLights.lightCount));
	//int lightIDX = 0;
	vec3 dirToLight = normalize(uboLights.pos[lightIDX].xyz - pos);
	return dirToLight;
}

#define KD 0.05 // diffuse

#define ALBEDO_MULT 1.3
vec4 path_tracer(){
	const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);
	const vec2 screen_coord_cs  = inUV * 2.0 - 1.0;

	// init ray
	Ray ray = get_primary_ray(screen_coord_cs);
	//ray.origin = position.xyz;
	//vec4 target = ubo.inverseProj * vec4(screen_coord_cs, -1, 1) ;
	//ray.direction = (ubo.inverseView*vec4(normalize(target.xyz), 0)).xyz;
	//ray.t_min = 0.01;
	//ray.t_max = 10000.0;

	// calc ray length
	//trace_ray(ray, RAY_FIRST_PERSON_OPAQUE_VISIBLE);
	//ray.t_max = rp.hit_distance + 0.001;

	trace_ray(ray, RAY_FIRST_PERSON_OPAQUE_VISIBLE | RAY_FIRST_PERSON_PARTICLE_VISIBLE);
	if(!found_intersection(rp)){
		//return alpha_blend_premultiplied(rp.transparent, sampleSky(ray.direction));
		return sampleSky(ray.direction);
	}

	HitPoint hp = getHitPoint(rp);
	Triangle triangle = getTriangle(rp);

	vec4 color = vec4(0,0,0,0);
	if(is_mirror(rp)){
		ray.origin = ray.origin + ray.direction * rp.hit_distance;
		ray.direction = reflect(ray.direction, hp.normal);
		trace_ray(ray, RAY_MIRROR_OPAQUE_VISIBLE | RAY_MIRROR_PARTICLE_VISIBLE);
		hp = getHitPoint(rp);
		if(!found_intersection(rp)){
			return alpha_blend_premultiplied(rp.transparent, sampleSky(ray.direction));
		}
		color = texture(texure_array[uint(uint(iData.data[rp.instanceID].texIdx))], hp.uv);
		return color;
	} 

	vec4 contrib = vec4(0,0,0,0);

	vec3 fromCam = ray.direction.xyz;
	vec3 primary_albedo = getTextureLod(screen_coord_cs, triangle, hp).xyz;
	if(is_light(rp)){
	 	primary_albedo += vec3(1,0,0);
	}
	if(is_glass(rp)){
		primary_albedo += vec3(0,0,1);
	}

	vec3 directLightContrib = vec3(0); 
	vec3 indirectLightContrib = vec3(0); 

	vec3 P = hp.pos.xyz;
	vec3 N = hp.normal;
	for(int i = 0; i < 10/*uboLights.lightCount*/; i++){
		vec3 L =  getLightDir(P, i);
		//vec3 L =  normalize(uboLights.pos[i].xyz - P);
		//vec2 L = scene->lights[i].getLightDirection(P); 
        vec3 L_i = 1.0f * vec3(0.5,0.5,0.5); // intensity * l color
        // we assume the surface at P is diffuse
		ray.origin = P;
		ray.direction = L;

		float t_min = 0.01;
		//if(dot(L, N) > 0) t_min = -0.01;
		if(dot(L, N) > 0) {
			//continue;
			N = -N;
			//t_min = -0.01;
		}
		directLightContrib += int(trace_shadow_ray(P, L, t_min)) * max(0.f, dot(N,-L)) * L_i; 

	}

	color = vec4((directLightContrib) * primary_albedo, 1);
 //color = vec4(primary_albedo, 1);

	//vec3 contrib    = vec3(0);
	//vec3 throughput = vec3(1);
	//color = getTextureLod(screen_coord_cs, triangle, hp);

	//color = texture(blue_noise, vec3(hp.uv, 16)).rrrr;
	// mark lights and glass
	// if(is_light(rp)){
	// 	color += vec4(1,0,0,0);
	// } else
	// if(is_glass(rp)){
	// 	color += vec4(0,0,1,0);
	// }
	// vec3 direction = ray.direction;
	// vec3 normal = hp.normal;
	// float NdotV = -dot(normal, direction); // cos_theta 
	// if (NdotV<0) 
    // {
    //     NdotV = -NdotV;
    // }
	// float BRDF = 1.0f/M_PI;

	// vec3 emittance = vec3(1,1,1);
	//color.rgb = emittance + (BRDF * incoming * cos_theta / p);
	//color.rgb =


	// vec3 primary_albedo = vec3(1);
	// float primary_metallic = 0;
	// float primary_specular = 0;
	// float primary_roughness = 1;
	// vec3 primary_emissive = vec3(0);
	// vec3 throughput = vec3(1);

    // primary_albedo = getTextureLod(screen_coord_cs, triangle, hp).xyz;
	// primary_metallic = 0.5;
	// primary_specular = mix(0.05, 1.0, primary_metallic);
	// primary_roughness = 0.5;

	// primary_specular = schlick_ross_fresnel(primary_specular, primary_roughness, NdotV);
	// primary_specular *= (1 - primary_roughness * (1 - primary_metallic) * 0.9);

	// vec3 final_color;
	// vec3 diff_color = primary_albedo * (1 - primary_specular);
	// vec3 spec_color = mix(vec3(1), primary_albedo, primary_metallic) * primary_specular;
        
    // final_color = diff_color + vec3(0.4,0.4,0.4)/*specular.rgb*/ * spec_color;
    // final_color *= throughput;

	// color.rgb = final_color;

	

	// direct light
#define RNG_NEE_LIGHT_SELECTION(bounce)   (2 + 0 + 9 * bounce)
#define RNG_NEE_TRI_X(bounce)             (2 + 1 + 9 * bounce)
#define RNG_NEE_TRI_Y(bounce)             (2 + 2 + 9 * bounce)

	//if(dot(ray.direction, hp.normal) > 0) hp.normal = -hp.normal;
	
	// ray.origin = hp.pos.xyz;
	// ray.direction = getLights(hp);
	// //ray.t_min = -0.01;
	// if(dot(ray.direction, hp.normal) > 0) ray.t_min = -0.01;

	// trace_ray(ray, RAY_FIRST_PERSON_OPAQUE_VISIBLE | RAY_FIRST_PERSON_PARTICLE_VISIBLE);
	// hp = getHitPoint(rp);
	// if((iData.data[rp.instanceID].material & MATERIAL_FLAG_LIGHT) == MATERIAL_FLAG_LIGHT){
	// } 
	// else	color -= vec4(0.2,0.2,0.2,0);

	#ifdef GLSL
	//color = vec4(vec3( get_rng(0, int(ubo.frameIndex)) ), color.w);

	//int lightIDX = int( get_rng(0, int(ubo.frameIndex)) * (uboLights.lightCount) );
	//if(lightIDX  > 5) color = vec4(1,0,0,0);
	#endif
	//color = texelFetch(blue_noise, ivec3(gl_LaunchIDNV.xy % (BLUE_NOISE_RES ), 10), 0).rrrr;
	// vec4 shadow = vec4(0);

	// for(int i = 0; i < 2/*uboLights.lightCount*/; i++){

	// 	{
	// 		int lightIDX = int(round(get_rng(i) * float(uboLights.lightCount)));
	// 		vec3 dirToLight = normalize(uboLights.pos[lightIDX].xyz - hp.pos.xyz);
	// 		ray.origin = hp.pos.xyz;
	// 		ray.direction = dirToLight;
	// 		trace_ray(ray, RAY_FIRST_PERSON_OPAQUE_VISIBLE | RAY_FIRST_PERSON_PARTICLE_VISIBLE);
	// 		hp = getHitPoint(rp.instanceID, rp.primitiveID, rp.barycentric);
	// 		if((iData.data[rp.instanceID].material & MATERIAL_FLAG_LIGHT) == MATERIAL_FLAG_LIGHT){
	// 		} 
	// 		else	shadow += vec4(0.10,0.1,0.1,0);
	// 	}
	// }
	
	// color -= shadow;

	//color = vec4(get_rng(1));//texelFetch(blue_noise, ivec3(gl_LaunchIDNV.xy % (BLUE_NOISE_RES ), 0), 0).rrrr;
	// //mirror
	// if((iData.data[rp.instanceID].material & MATERIAL_FLAG_MIRROR) == MATERIAL_FLAG_MIRROR){
	// 	contrib = texture(texure_array[uint(uint(iData.data[rp.instanceID].texIdx))], hp.uv);
	// 	color = alpha_blend_premultiplied(rp.transparent, contrib);

	// 	ray.origin = ray.origin + ray.direction * rp.hit_distance;
	// 	ray.direction = reflect(ray.direction, hp.normal);
	// 	trace_ray(ray, RAY_MIRROR_OPAQUE_VISIBLE | RAY_MIRROR_PARTICLE_VISIBLE);
	// 	hp = getHitPoint(rp.instanceID, rp.primitiveID, rp.barycentric);

	// 	if(!found_intersection(rp)){
	// 		return alpha_blend_premultiplied(rp.transparent, sampleSky(ray.direction));
	// 	}

	// 	contrib = texture(texure_array[uint(uint(iData.data[rp.instanceID].texIdx))], hp.uv);
	// 	vec4 color2 = alpha_blend_premultiplied(rp.transparent, contrib);
	// 	color =  alpha_blend_premultiplied(color, color2);
	// } 
	// // view through portal
	// else if(ubo.hasPortal && (iData.data[rp.instanceID].material & MATERIAL_FLAG_PORTAL) == MATERIAL_FLAG_PORTAL){
	// 	ray.origin = positionPortal.xyz;
	// 	target = ubo.inverseProjPortal * vec4(screen_coord_cs, -1, 1) ;
	// 	ray.direction = (ubo.inverseViewPortal*vec4(normalize(target.xyz), 0)).xyz;
	// 	trace_ray(ray, RAY_FIRST_PERSON_OPAQUE_VISIBLE | RAY_FIRST_PERSON_PARTICLE_VISIBLE);
	// 	if(!found_intersection(rp)){
	// 		return alpha_blend_premultiplied(rp.transparent, sampleSky(ray.direction));
	// 	}
	// 	hp = getHitPoint(rp.instanceID, rp.primitiveID, rp.barycentric);
	// 	return color = texture(texure_array[uint(uint(iData.data[rp.instanceID].texIdx))], hp.uv);
	// }
	// else {
	// 	contrib = texture(texure_array[uint(uint(iData.data[rp.instanceID].texIdx))], hp.uv);
	// 	color = alpha_blend_premultiplied(rp.transparent, contrib);
	// }

	//  if((iData.data[rp.instanceID].material & MATERIAL_FLAG_LIGHT) == MATERIAL_FLAG_LIGHT){
	//  	color = vec4(0,1,0,0);
	// }
	
	
	//for see through objects we need another ray
	// if((iData.data[rp.instanceID].material & MATERIAL_FLAG_SEE_THROUGH) > 0){
	// 	ray.origin = hp.pos;
	// 	trace_ray(ray, RAY_FIRST_PERSON_OPAQUE_VISIBLE | RAY_FIRST_PERSON_PARTICLE_VISIBLE);
	// 	if(found_intersection(rp)){
	// 		hp = getHitPoint(rp.instanceID, rp.primitiveID, rp.barycentric);
	// 		contrib = texture(texure_array[uint(uint(iData.data[rp.instanceID].texIdx))], hp.uv);
	// 		vec4 color2 = alpha_blend_premultiplied(rp.transparent, contrib);
	// 		color =  alpha_blend_premultiplied(color, color2);
	// 	}
	// }
	
	return vec4(color.xyz, false);
}

void main() 
{
	vec4 color = path_tracer();
	color.rgb = max(vec3(0), color.rgb);
	if(any(isnan(color.rgb)))
		color.rgb = vec3(0);

	color.rgb = clamp_color(color.rgb, 128.0);

	imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(color.xyz,1));
}


//color = contrib * ALBEDO_MULT;
	// vec3 throughput = vec3(1);
	// const int num_bounces = 3;
	// vec3 bounceContrib = color.xyz;
	// for(int i = 0; i < num_bounces; i++) {
	// 	if(dot(ray.direction, hp.normal) > 0)
	// 		hp.normal = -hp.normal;

	// 	ray.origin = hp.pos;
	// 	ray.direction = reflect(ray.direction, hp.normal);

	// 	trace_ray(ray, RAY_FIRST_PERSON_OPAQUE_VISIBLE);
	// 	hp = getHitPoint(rp.instanceID, rp.primitiveID, rp.barycentric);

	// 	if(!found_intersection(rp)) {
	// 		vec4 env = sampleSky(ray.direction);
	// 		//contrib += env * throughput;
	// 		break;
	// 	}

	// 	vec4 contrib2 = global_textureLod(uint(uint(iData.data[rp.instanceID].texIdx)), hp.uv, i/2);
	// 	bounceContrib.xyz += contrib2.xyz * throughput;
	// 	throughput *= 0.8;
	// 	// {
	// 	// 	Triangle triangle = get_hit_triangle(ray_payload_brdf);
	// 	// 	vec3 bary         = get_hit_barycentric(ray_payload_brdf);
	// 	// 	vec2 tex_coord    = triangle.tex_coords * bary;

	// 	// 	/* world-space */
	// 	// 	position       = triangle.positions * bary;
	// 	// 	normal         = normalize(triangle.normals * bary);
	// 	// 	material_id    = triangle.material_id;
	// 	// 	albedo         = global_textureLod(triangle.material_id, tex_coord, i / 2).rgb;
	// 	// 	cluster_idx    = triangle.cluster;

	// 	// 	contrib += albedo * throughput;
	// 	// 	throughput *= 0.8;

	// 	// }
	// }
	// color.xyz = bounceContrib;
	
	//pixelColor += rp.color;

//traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
	// init payload
	//initPayload(rp);
	// } else{
	// 	HitPoint hp = getHitPoint(rp.instanceID, rp.primitiveID, rp.barycentric);
	// 	vec4 c = texture(tex[uint(uint(iData.data[rp.instanceID].texIdx))], hp.uv);
	// 	if((iData.data[rp.instanceID].type & S_TYPE_NEEDSCOLOR) > 0){
	// 		c = c * (hp.color/255);
	// 	} 

	// 	uint blendFunc = iData.data[rp.instanceID].blendfunc;

	// 	if(iData.data[rp.instanceID].shaderSort > SS_OPAQUE){
	// 		//c = vec4(1,0,0,0);
	// 		ray.origin += ray.direction * rp.hit_distance;
	// 		trace_ray(ray);
	// 		if(!found_intersection(rp)){
	// 			return sampleSky(ray.direction);
	// 		}

	// 		hp = getHitPoint(rp.instanceID, rp.primitiveID, rp.barycentric);
	// 		if(blendFunc == (GLS_SRCBLEND_SRC_ALPHA | GLS_DSTBLEND_ONE_MINUS_SRC_ALPHA)){
	// 			vec4 c2 = /*(hp.color/255) */ texture(tex[uint(uint(iData.data[rp.instanceID].texIdx))], hp.uv);
	// 			if((iData.data[rp.instanceID].type & S_TYPE_NEEDSCOLOR) > 0) c2 = c2 * (hp.color/255);
	// 			c = blendColor(c, c2, blendFunc );
	// 		} else {
	// 			c += /*(hp.color/255) */ texture(tex[uint(uint(iData.data[rp.instanceID].texIdx))], hp.uv);
	// 		}
	// 		//c = ((hp.color/255) * c).wwww;
	// 	}
		// if(iData.data[rp.instanceID].shaderSort > SS_OPAQUE){
		// ray.origin += ray.direction * rp.hit_distance;
		// trace_ray(ray);
		// hp = getHitPoint(rp.instanceID, rp.primitiveID, rp.barycentric);
		// c += (hp.color/255) * texture(tex[uint(uint(iData.data[rp.instanceID].texIdx))], hp.uv);
		// }
/*
// Trace hit.
		origin.xyz = origin.xyz + rp.distance * direction.xyz;
	//pixelColor = vec4(pixelColor.w,pixelColor.w,pixelColor.w,pixelColor.w);
	if(pixelColor.w == 0) {
		traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
		pixelColor += rp.color;
	}else(rp.transparent > 0 && pixelColor.w != 1)  {
		traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
		pixelColor += rp.color;
			//pixelColor = vec4(((1-pixelColor.w) * pixelColor.xyz) + ((pixelColor.w) * rp.color.xyz), 1);
	}*/
/*
	for (uint s = 0; s < 5; ++s)
	{
		if (rp.distance < 0 || rp.transparent == 0)
		{				
			break;
		}
		// Trace hit.
		origin.xyz = origin.xyz + rp.distance * direction.xyz;

		if(pixelColor.w == 0) {
			traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
			pixelColor += rp.color;
		}
		else(pixelColor.w != 1)  {
			//traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
			//pixelColor = vec4(((1-pixelColor.w) * pixelColor.xyz) + ((pixelColor.w) * rp.color.xyz), 1);
		}
		*/
		//if((rp.transparent == 1) || (rp.transparent == 2 && pixelColor.w != 1))traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
		//pixelColor = blendColor(pixelColor, rp.color, uint(rp.blendFunc));
		//if(rp.transparent == 2) {

		//else pixelColor += rp.color;
		

		
	//}
	//traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz + (direction.xyz * rp.distance), tmin, direction.xyz, tmax, 0);
	
//}